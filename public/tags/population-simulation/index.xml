<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Population Simulation on mrgsolve</title>
    <link>/tags/population-simulation/index.xml</link>
    <description>Recent content in Population Simulation on mrgsolve</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/population-simulation/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Flexible, heterogeneous simulation designs in a population</title>
      <link>/2017/01/05/flexible-heterogeneous-simulation-designs-in-a-population/</link>
      <pubDate>Thu, 05 Jan 2017 13:09:02 +0000</pubDate>
      
      <guid>/2017/01/05/flexible-heterogeneous-simulation-designs-in-a-population/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;



&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;

&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;Design lists help you assign different designs to different groups in a population or specific designs to specific individuals.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mrgsolve)
library(dplyr)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;assign-designs-to-individuals&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Assign designs to individuals&lt;/h3&gt;
&lt;p&gt;To illustrate, let’s make a population of 4 individuals, all with different simulation &lt;strong&gt;end&lt;/strong&gt; times.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;des &amp;lt;- data_frame(ID=1:4, end=seq(24,96,24))

des&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. # A tibble: 4 × 2
.      ID   end
.   &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;
. 1     1    24
. 2     2    48
. 3     3    72
. 4     4    96&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For simplicity, we will only vary the simulation end time in this example. See later examples where &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;delta&lt;/code&gt; and &lt;code&gt;add&lt;/code&gt; can varied as well.&lt;/p&gt;
&lt;p&gt;We can turn this in to a list of designs with &lt;code&gt;as_deslist&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as_deslist(des, descol=&amp;quot;ID&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. $ID_1
. start:  0  end:    24  delta:  1  offset: 0  min:    0   max:    24 
. 
. $ID_2
. start:  0  end:    48  delta:  1  offset: 0  min:    0   max:    48 
. 
. $ID_3
. start:  0  end:    72  delta:  1  offset: 0  min:    0   max:    72 
. 
. $ID_4
. start:  0  end:    96  delta:  1  offset: 0  min:    0   max:    96 
. 
. attr(,&amp;quot;descol&amp;quot;)
. [1] &amp;quot;ID&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;as_deslist&lt;/code&gt; returns one design for each individual, one for each unique level of &lt;code&gt;descol&lt;/code&gt;. The deslist is a list of &lt;code&gt;tgrid&lt;/code&gt; objects (see &lt;code&gt;?tgrid&lt;/code&gt;). Note also that &lt;code&gt;descol&lt;/code&gt; is retained as an attribute to be used later.&lt;/p&gt;
&lt;p&gt;Let’s set up a simulation that includes these 4 IDs; we load a model and, importantly, set up an &lt;code&gt;idata_set&lt;/code&gt; for the simulation that includes all 4 IDs in the design list.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod &amp;lt;- mrgsolve:::house() %&amp;gt;% ev(amt=100)

idata &amp;lt;- select(des,ID)
idata&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. # A tibble: 4 × 1
.      ID
.   &amp;lt;int&amp;gt;
. 1     1
. 2     2
. 3     3
. 4     4&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;des1 &amp;lt;- as_deslist(des,&amp;quot;ID&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run the simulation, pass in the design list to &lt;code&gt;design&lt;/code&gt; in the pipeline&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;out &amp;lt;- 
  mod %&amp;gt;%
  idata_set(idata) %&amp;gt;%
  design(des1) %&amp;gt;%
  mrgsim&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We see that ID 1 has a 24 hour end time, ID 2 has 48 hour simulation time, ID 3 with 72 hour simulation time, and ID 4 96 hour simulation time as reflected in the list of the designs.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(out, CP~time|ID)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/05/flexible-heterogeneous-simulation-designs-in-a-population/figures/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: Check the arguments to &lt;code&gt;design&lt;/code&gt; (&lt;code&gt;?design&lt;/code&gt;). There is a &lt;code&gt;descol&lt;/code&gt; argument that is required. &lt;code&gt;descol&lt;/code&gt; in this function refers to a column in &lt;code&gt;idata_set&lt;/code&gt; to be used as the grouping variable to assign the sampling design. &lt;code&gt;as_deslist&lt;/code&gt; also had a &lt;code&gt;descol&lt;/code&gt; argument that referred to a column in the input data frame for that function. We don’t need to pass &lt;code&gt;descol&lt;/code&gt; to &lt;code&gt;design()&lt;/code&gt; because we created the design list with &lt;code&gt;as_deslist&lt;/code&gt;: &lt;code&gt;design()&lt;/code&gt; reads &lt;code&gt;descol&lt;/code&gt; from the attribute. We don’t &lt;strong&gt;have&lt;/strong&gt; to use &lt;code&gt;as_deslist&lt;/code&gt; to create the design list. It could be just a plan old &lt;code&gt;R&lt;/code&gt; list created by you with &lt;code&gt;tgrid&lt;/code&gt; objects. In that case, you must state what &lt;code&gt;descol&lt;/code&gt; is when you call &lt;code&gt;design()&lt;/code&gt;.&lt;br /&gt;
And it can’t be emphasized enough here that you &lt;strong&gt;MUST&lt;/strong&gt; use an &lt;code&gt;idata_set&lt;/code&gt; for this to work and &lt;code&gt;idata_set&lt;/code&gt; must contain a valid &lt;code&gt;descol&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;assign-designs-to-treatment-arms-or-groups&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Assign designs to treatment arms or groups&lt;/h3&gt;
&lt;p&gt;Now, let’s simulate a trial with 5 patients in each of 4 treatment arms. In this trial, arm 1 lasts 24 hours, arm 2 last 48 hours … etc. But every patient with the arm 1 indicator will get simulated for 24 hours, every patient with arm 2 indicator will get simulated for 48 hours and so on.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;idata &amp;lt;- expand.idata(ARM=1:4,ID=1:5)

head(idata)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID ARM
. 1  1   1
. 2  2   2
. 3  3   3
. 4  4   4
. 5  5   1
. 6  6   2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let’s setup the designs based on &lt;code&gt;ARM&lt;/code&gt; rather than &lt;code&gt;ID&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;des &amp;lt;- distinct(idata,ARM) %&amp;gt;% mutate(end=seq(24,96,24))

des&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ARM end
. 1   1  24
. 2   2  48
. 3   3  72
. 4   4  96&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The simulation works the same way&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(11)

out &amp;lt;- 
  mod %&amp;gt;% 
  idata_set(idata) %&amp;gt;%
  omat(dmat(1,1,1,1)/10) %&amp;gt;%
  design(as_deslist(des,&amp;quot;ARM&amp;quot;)) %&amp;gt;% 
  mrgsim(carry.out=&amp;quot;ARM&amp;quot;)

plot(out, CP~time|factor(ARM))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/05/flexible-heterogeneous-simulation-designs-in-a-population/figures/unnamed-chunk-10-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(out, CP~time|factor(ID))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/05/flexible-heterogeneous-simulation-designs-in-a-population/figures/unnamed-chunk-10-2.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;list-cols-and-additional-times&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;list-cols&lt;/code&gt; and &lt;code&gt;additional&lt;/code&gt; times&lt;/h3&gt;
&lt;p&gt;Hopefully it’s clear that columns named &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;delta&lt;/code&gt; in the the input data frame passed to &lt;code&gt;as_deslist&lt;/code&gt; are just numeric values that form the time grid object (see &lt;code&gt;?tgrid&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;What about &lt;code&gt;add&lt;/code&gt;, the vector of ad-hoc times for the simulation? These, too, can be accommodated with a &lt;code&gt;list-col&lt;/code&gt; column in the input data frame. Note that &lt;code&gt;list-cols&lt;/code&gt; are only really supported in specialized &lt;code&gt;tibble&lt;/code&gt; type data frames.&lt;/p&gt;
&lt;p&gt;These are random times for IDs 1 and 2&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(12)
t1 &amp;lt;- c(0,sample(1:24,12))
t2 &amp;lt;- c(0,sample(1:96,12))

t1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.  [1]  0  2 19 21  6  4  1 20 11 23 16 22 17&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.  [1]  0 37 96 25 41 43 50 60 11 20 69  9 61&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: When we simulate with &lt;code&gt;end &amp;lt; 0&lt;/code&gt;, &lt;code&gt;mrgsolve&lt;/code&gt; knows to ignore &lt;code&gt;start/end/delta&lt;/code&gt; and only use the times in &lt;code&gt;add&lt;/code&gt; for observations.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;des &amp;lt;- data_frame(ID=1:2, end=-1, add=list(t1,t2))
des&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. # A tibble: 2 × 3
.      ID   end        add
.   &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;     &amp;lt;list&amp;gt;
. 1     1    -1 &amp;lt;dbl [13]&amp;gt;
. 2     2    -1 &amp;lt;dbl [13]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod %&amp;gt;% 
  idata_set(des, select=ID) %&amp;gt;%
  design(as_deslist(des)) %&amp;gt;% 
  mrgsim %&amp;gt;% 
  plot(CP~time|factor(ID), type=&amp;#39;b&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/05/flexible-heterogeneous-simulation-designs-in-a-population/figures/unnamed-chunk-12-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ok … not the most lovely-looking result we’ve seen before, but maybe that’s just what you needed in this simulation.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Generating input data sets for mrgsolve</title>
      <link>/2017/01/01/generating-input-data-sets-for-mrgsolve/</link>
      <pubDate>Sun, 01 Jan 2017 13:09:13 -0600</pubDate>
      
      <guid>/2017/01/01/generating-input-data-sets-for-mrgsolve/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;



&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;

&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;&lt;BR&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mrgsolve)
library(dplyr)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;input-data-sets&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Input data sets&lt;/h2&gt;
&lt;p&gt;An important mechanism for creating robust, complex simulations is the input data set. Input data sets specify the population of individuals to simulate, including the number of individuals, each individual’s dosing interventions, each individual’s covariate values etc. The input data set is just a plain old &lt;code&gt;R&lt;/code&gt; &lt;code&gt;data.frame&lt;/code&gt;, but with some expectations about which columns are present and expectations for how to handle columns for certain names. For example, every input data set has to have an &lt;code&gt;ID&lt;/code&gt;, &lt;code&gt;time&lt;/code&gt;, and &lt;code&gt;cmt&lt;/code&gt; column. Note that either lower case names (like &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;cmt&lt;/code&gt;) are acceptable as are upper case names (like &lt;code&gt;TIME&lt;/code&gt; and &lt;code&gt;CMT&lt;/code&gt;). But users are not to mix upper and lower case names (like &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;CMT&lt;/code&gt;) for certain column names related to dosing events. The help topic &lt;code&gt;?data_set&lt;/code&gt; discusses more about what the expectations are for input data sets.&lt;/p&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div id=&#34;functions-to-generate-input-data-sets&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Functions to generate input data sets&lt;/h2&gt;
&lt;code&gt;mrgsolve&lt;/code&gt; provides several functions and workflows to help you put together the right input data set for your simulation. The main point of this blog post is to review some of these functions to help you better organize your &lt;code&gt;mrgsolve&lt;/code&gt; simulations. Some functions are very simple and you might not find a function to do &lt;strong&gt;exactly&lt;/strong&gt; what you want to do. But we’ve found these functions to be helpful to accomplish tasks that we found ourselves repeating over and over … and thus these tasks were formalized in a function. Just keep in mind that input data sets are just &lt;code&gt;data.frames&lt;/code&gt; … you can use any code or any function (even your own!) to do tasks similar to what these functions are doing.
&lt;hr&gt;
&lt;div id=&#34;expand.ev&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;expand.ev&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;expand.ev&lt;/code&gt; is like &lt;code&gt;expand.grid&lt;/code&gt;: it creates a single &lt;code&gt;data.frame&lt;/code&gt; with all combinations of it’s vector arguments. It’s pretty simple but convenient to have. For example,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- expand.ev(amt=c(100,200,300), ID=1:3)
data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID amt evid cmt time
. 1  1 100    1   1    0
. 2  2 200    1   1    0
. 3  3 300    1   1    0
. 4  4 100    1   1    0
. 5  5 200    1   1    0
. 6  6 300    1   1    0
. 7  7 100    1   1    0
. 8  8 200    1   1    0
. 9  9 300    1   1    0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function call gives us 3 individuals at each of 3 doses. The &lt;code&gt;expand.grid&lt;/code&gt; nature of &lt;code&gt;expand.ev&lt;/code&gt; is what gives us &lt;code&gt;3x3=9&lt;/code&gt; rows in the data set. Notice that the &lt;code&gt;IDs&lt;/code&gt; are now 1 through 9 … &lt;code&gt;expand.ev&lt;/code&gt; renumbers &lt;code&gt;IDs&lt;/code&gt; so that there is only one dosing event per row and there is on row per &lt;code&gt;ID&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also notice that &lt;code&gt;time&lt;/code&gt; defaults to 0, &lt;code&gt;evid&lt;/code&gt; defaults to 1, and &lt;code&gt;cmt&lt;/code&gt; defaults to 1. So, &lt;code&gt;expand.ev&lt;/code&gt; fills in some of the required columns for you.&lt;/p&gt;
&lt;p&gt;Let’s simulate with this data set:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod &amp;lt;- mrgsolve:::house() %&amp;gt;% Req(CP) 
mod %&amp;gt;% 
  mrgsim(data=data) %&amp;gt;% 
  plot(CP~time|factor(ID),scales=&amp;quot;same&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/01/generating-input-data-sets-for-mrgsolve/figures/unnamed-chunk-4-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div id=&#34;as_data_set&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;as_data_set&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This function allows you to combine several event objects into a single data sets. An example works best to illustrate.&lt;/p&gt;
&lt;p&gt;First, create three event objects. Let’s try one &lt;code&gt;ID&lt;/code&gt; at 100 mg, two &lt;code&gt;IDs&lt;/code&gt; at 200 mg, and 3 &lt;code&gt;IDs&lt;/code&gt; at 300 mg.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e1 &amp;lt;- ev(amt=100, ID=1)
e2 &amp;lt;- ev(amt=200, ID=1:2)
e3 &amp;lt;- ev(amt=300, ID=1:3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The events are&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid
. 1  1    0   1 100    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e2&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid
. 1  1    0   1 200    1
. 2  2    0   1 200    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid
. 1  1    0   1 300    1
. 2  2    0   1 300    1
. 3  3    0   1 300    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we combine these events with &lt;code&gt;as_data_set&lt;/code&gt; we get&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- as_data_set(e1,e2,e3)
data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID time cmt evid amt
. 1  1    0   1    1 100
. 2  2    0   1    1 200
. 3  3    0   1    1 200
. 4  4    0   1    1 300
. 5  5    0   1    1 300
. 6  6    0   1    1 300&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A nice feature of &lt;code&gt;as_data_set&lt;/code&gt; is, unlike &lt;code&gt;expand.ev&lt;/code&gt; and the previous example, we can use complicated event sequences that are expressed with more than one line in the data set. For example, consider the case where every &lt;code&gt;ID&lt;/code&gt; gets a 250 mg loading dose, and then either get 250 mg q24h, or 120 mg q12h or 500 mg q48h.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;load &amp;lt;- function(n) ev(amt=250, ID=1:n)
e1 &amp;lt;- load(1) + ev(amt=250, time=24, ii=24, addl=3, ID=1)
e2 &amp;lt;- load(2) + ev(amt=125, time=24, ii=12, addl=7, ID=1:2)
e3 &amp;lt;- load(3) + ev(amt=500, time=24, ii=48, addl=1, ID=1:3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, &lt;code&gt;e1&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt;, and &lt;code&gt;e3&lt;/code&gt; are more complex&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e1&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid ii addl
. 1  1    0   1 250    1  0    0
. 2  1   24   1 250    1 24    3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e3&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid ii addl
. 1  1    0   1 250    1  0    0
. 4  1   24   1 500    1 48    1
. 2  2    0   1 250    1  0    0
. 5  2   24   1 500    1 48    1
. 3  3    0   1 250    1  0    0
. 6  3   24   1 500    1 48    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, we can still pull them together in one single data set&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- as_data_set(e1,e2,e3)
data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.    ID time cmt evid amt ii addl
. 1   1    0   1    1 250  0    0
. 2   1   24   1    1 250 24    3
. 3   2    0   1    1 250  0    0
. 4   2   24   1    1 125 12    7
. 5   3    0   1    1 250  0    0
. 6   3   24   1    1 125 12    7
. 7   4    0   1    1 250  0    0
. 8   4   24   1    1 500 48    1
. 9   5    0   1    1 250  0    0
. 10  5   24   1    1 500 48    1
. 11  6    0   1    1 250  0    0
. 12  6   24   1    1 500 48    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An example simulation&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1112)
mod %&amp;gt;% 
  omat(dmat(1,1,1,1)/10) %&amp;gt;% 
  data_set(data) %&amp;gt;% 
  mrgsim() %&amp;gt;% 
  plot&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;/2017/01/01/generating-input-data-sets-for-mrgsolve/figures/unnamed-chunk-13-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div id=&#34;as.data.frame.ev&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;as.data.frame.ev&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Just a quick reminder here that you can easily convert between a single event object and a &lt;code&gt;data.frame&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.data.frame(e3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID time cmt amt evid ii addl
. 1  1    0   1 250    1  0    0
. 4  1   24   1 500    1 48    1
. 2  2    0   1 250    1  0    0
. 5  2   24   1 500    1 48    1
. 3  3    0   1 250    1  0    0
. 6  3   24   1 500    1 48    1&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;as.ev(as.data.frame(e3))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid ii addl
. 1  1    0   1 250    1  0    0
. 4  1   24   1 500    1 48    1
. 2  2    0   1 250    1  0    0
. 5  2   24   1 500    1 48    1
. 3  3    0   1 250    1  0    0
. 6  3   24   1 500    1 48    1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So if you were building up an event object and just wanted to use it as a &lt;code&gt;data_set&lt;/code&gt; or as a building block for a &lt;code&gt;data_set&lt;/code&gt;, just coerce with &lt;code&gt;as.data.frame&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div id=&#34;assign_ev&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;assign_ev&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This function assigns an intervention in the form of an event object to individuals in an &lt;code&gt;idata_set&lt;/code&gt; according to a grouping column.&lt;/p&gt;
&lt;p&gt;To illustrate, make a simple &lt;code&gt;idata_set&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(8)
idata &amp;lt;- data_frame(ID=sample(1:6), arm=c(1,2,2,3,3,3))
idata&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. # A tibble: 6 × 2
.      ID   arm
.   &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;
. 1     3     1
. 2     2     2
. 3     4     2
. 4     5     3
. 5     1     3
. 6     6     3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we have 6 &lt;code&gt;IDs&lt;/code&gt;, one in arm 1, two in arm 2, three in arm 3. Let’s take the events from the previous example and assign them to the different arms.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e1 &amp;lt;- ev(amt=250) + ev(amt=250, time=24, ii=24, addl=3)
e2 &amp;lt;- ev(amt=250) + ev(amt=125, time=24, ii=12, addl=7)
e3 &amp;lt;- ev(amt=250) + ev(amt=500, time=24, ii=48, addl=1)
assign_ev(list(e3,e2,e1),idata,&amp;quot;arm&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.    time cmt amt evid ii addl ID
. 1     0   1 250    1  0    0  3
. 2    24   1 500    1 48    1  3
. 3     0   1 250    1  0    0  2
. 4    24   1 125    1 12    7  2
. 5     0   1 250    1  0    0  4
. 6    24   1 125    1 12    7  4
. 7     0   1 250    1  0    0  5
. 8    24   1 250    1 24    3  5
. 9     0   1 250    1  0    0  1
. 10   24   1 250    1 24    3  1
. 11    0   1 250    1  0    0  6
. 12   24   1 250    1 24    3  6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Please look carefully at the input (&lt;code&gt;idata&lt;/code&gt; and &lt;code&gt;list(e3,e2,e1)&lt;/code&gt;); I have mixed it up a bit here to try to illustrate how things are assigned.&lt;/p&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;div id=&#34;ev_days&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;code&gt;ev_days&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This is a recently-added function (hint: you might need to install the latest version from GitHub to use this) that lets you schedule certain events on certain days of the week, repeating in a weekly cycle.&lt;/p&gt;
&lt;p&gt;For example, to schedule 250 mg doses every Monday, Wednesday, and Friday for a month, you can do&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- ev_days(ev(amt=250, ID=1), days=&amp;quot;m,w,f&amp;quot;, addl=3)
data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID time cmt amt evid  ii addl
. 1  1    0   1 250    1 168    3
. 2  1   48   1 250    1 168    3
. 3  1   96   1 250    1 168    3&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod %&amp;gt;% mrgsim(data=data,end=168*4) %&amp;gt;% plot&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/01/generating-input-data-sets-for-mrgsolve/figures/unnamed-chunk-17-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Or, you can do 100 mg doses on Monday, Wednesday, Friday, and 50 mg doses on Tuesday, Thursday, with drug holiday on weekends&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e1 &amp;lt;- ev(amt=100,ID=1)
e2 &amp;lt;- ev(amt=50,ID=1)
data &amp;lt;- ev_days(m=e1,w=e1,f=e1,t=e2,th=e2,addl=3)
data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID time cmt amt evid  ii addl
. 1  1    0   1 100    1 168    3
. 2  1   24   1  50    1 168    3
. 3  1   48   1 100    1 168    3
. 4  1   72   1  50    1 168    3
. 5  1   96   1 100    1 168    3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And simulate&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod %&amp;gt;% mrgsim(data=data,end=168*4) %&amp;gt;% plot&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/2017/01/01/generating-input-data-sets-for-mrgsolve/figures/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto auto auto 0;&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The same thing can be accomplished like this&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;a &amp;lt;- ev_days(e1,days=&amp;quot;m,w,f&amp;quot;,addl=3)
b &amp;lt;- ev_days(e2,days=&amp;quot;t,th&amp;quot;,addl=3)

c(as.ev(a),as.ev(b))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Events:
.   ID time cmt amt evid  ii addl
. 1  1    0   1 100    1 168    3
. 4  1   24   1  50    1 168    3
. 2  1   48   1 100    1 168    3
. 5  1   72   1  50    1 168    3
. 3  1   96   1 100    1 168    3&lt;/code&gt;&lt;/pre&gt;
You can use this as an event object or just coerce to &lt;code&gt;data.frame&lt;/code&gt; to use as a &lt;code&gt;data_set&lt;/code&gt;.
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;filter-input-data-set-inline&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Filter input data set inline&lt;/h2&gt;
&lt;p&gt;Remember, when you pass in your input data set via &lt;code&gt;data_set&lt;/code&gt;, you can filter in line:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- expand.ev(amt=c(100,200,300))
mod %&amp;gt;% data_set(data, amt==300) %&amp;gt;% Req(GUT,CP) %&amp;gt;% mrgsim&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Model:  housemodel.cpp 
. Dim:    482 x 4 
. Time:   0 to 120 
. ID:     1 
.      ID time    GUT     CP
. [1,]  3 0.00   0.00  0.000
. [2,]  3 0.00 300.00  0.000
. [3,]  3 0.25 222.25  3.862
. [4,]  3 0.50 164.64  6.676
. [5,]  3 0.75 121.97  8.712
. [6,]  3 1.00  90.36 10.174
. [7,]  3 1.25  66.94 11.211
. [8,]  3 1.50  49.59 11.934&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Resimulate random effect variates on demand</title>
      <link>/2017/01/01/resimulate-random-effect-variates-on-demand/</link>
      <pubDate>Sun, 01 Jan 2017 13:09:13 -0600</pubDate>
      
      <guid>/2017/01/01/resimulate-random-effect-variates-on-demand/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;



&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#simeta-example&#34;&gt;&lt;code&gt;simeta&lt;/code&gt; example&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#simulate-without-simeta&#34;&gt;Simulate without &lt;code&gt;simeta&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#simulate-with-simeta&#34;&gt;Simulate with &lt;code&gt;simeta&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#simeps-example&#34;&gt;&lt;code&gt;simeps&lt;/code&gt; example&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#simulate-without-simeps&#34;&gt;Simulate without &lt;code&gt;simeps&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#simulate-with-simeps&#34;&gt;Simulate with &lt;code&gt;simeps&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;&lt;BR&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(mrgsolve)
library(dplyr)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;simeta-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;simeta&lt;/code&gt; example&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;In this example, we want to simulate a patient-specific baseline response that is between 80 and 120.&lt;/li&gt;
&lt;li&gt;In the code, we start a loop that calls &lt;code&gt;simeta&lt;/code&gt; with no arguments until the baseline is between the specified bounds&lt;/li&gt;
&lt;li&gt;For this example, we only calculate &lt;code&gt;BASE&lt;/code&gt; when &lt;code&gt;NEWIND &amp;lt;=1&lt;/code&gt; … or whenever we are working on the first record of an individual. This ensures that we don’t re-simulate &lt;code&gt;BASE&lt;/code&gt; at every simulation record.&lt;/li&gt;
&lt;li&gt;We have also implemented a counter (&lt;code&gt;i&lt;/code&gt;) that ensures we only try to resimulate 100 times. If a value for &lt;code&gt;BASE&lt;/code&gt; cannot be generated in 100 tries, we give up.&lt;br /&gt;
&lt;/li&gt;
&lt;li&gt;You probably won’t need to implement &lt;code&gt;FLAG&lt;/code&gt; for your problem. I am only using &lt;code&gt;FLAG&lt;/code&gt; here so we can selectively call the &lt;code&gt;simeta&lt;/code&gt; code to demonstrate how it is working.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;code &amp;lt;- &amp;#39;
$PARAM TVBASE = 100, FLAG = 0

$CMT RESPONSE

$MAIN 

if(NEWIND &amp;lt;=1) {

  capture BASE = TVBASE*exp(EBASE);

  int i = 0;

  if(FLAG &amp;gt; 0) {
    while((BASE &amp;lt; 80) || (BASE &amp;gt; 120)) {
      if(++i &amp;gt; 100) {
        report(&amp;quot;There was a problem simulating BASE&amp;quot;);
      }
      simeta();
      BASE = TVBASE*exp(EBASE);
    }
  }
  
  RESPONSE_0 = BASE;
}


$OMEGA @labels EBASE
1

$CAPTURE EBASE
&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod &amp;lt;- mcode(&amp;quot;simeta&amp;quot;, code)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;simulate-without-simeta&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulate without &lt;code&gt;simeta&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time({
  out &amp;lt;- mod %&amp;gt;% mrgsim(nid=100, end=-1)
  sum &amp;lt;- summary(out)
})&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.    user  system elapsed 
.   0.012   0.000   0.012&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.        ID              time      RESPONSE           EBASE        
.  Min.   :  1.00   Min.   :0   Min.   :  14.97   Min.   :-1.8989  
.  1st Qu.: 25.75   1st Qu.:0   1st Qu.:  55.63   1st Qu.:-0.5865  
.  Median : 50.50   Median :0   Median : 117.65   Median : 0.1625  
.  Mean   : 50.50   Mean   :0   Mean   : 192.33   Mean   : 0.1915  
.  3rd Qu.: 75.25   3rd Qu.:0   3rd Qu.: 245.73   3rd Qu.: 0.8990  
.  Max.   :100.00   Max.   :0   Max.   :1372.70   Max.   : 2.6194  
.       BASE        
.  Min.   :  14.97  
.  1st Qu.:  55.63  
.  Median : 117.65  
.  Mean   : 192.33  
.  3rd Qu.: 245.73  
.  Max.   :1372.70&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we simulate with &lt;code&gt;FLAG=0&lt;/code&gt;, the &lt;code&gt;simeta&lt;/code&gt; code &lt;strong&gt;isn’t&lt;/strong&gt; called and we &lt;code&gt;BASE&lt;/code&gt; values all over the place.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulate-with-simeta&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulate with &lt;code&gt;simeta&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time({
  out &amp;lt;- mod %&amp;gt;% mrgsim(nid=100, end=-1, param=list(FLAG=1))
  sum &amp;lt;- summary(out)
})&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.    user  system elapsed 
.   0.008   0.000   0.008&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.        ID              time      RESPONSE          EBASE          
.  Min.   :  1.00   Min.   :0   Min.   : 80.04   Min.   :-0.222648  
.  1st Qu.: 25.75   1st Qu.:0   1st Qu.: 90.44   1st Qu.:-0.100474  
.  Median : 50.50   Median :0   Median :100.98   Median : 0.009781  
.  Mean   : 50.50   Mean   :0   Mean   :101.00   Mean   : 0.002831  
.  3rd Qu.: 75.25   3rd Qu.:0   3rd Qu.:111.00   3rd Qu.: 0.104401  
.  Max.   :100.00   Max.   :0   Max.   :119.97   Max.   : 0.182069  
.       BASE       
.  Min.   : 80.04  
.  1st Qu.: 90.44  
.  Median :100.98  
.  Mean   :101.00  
.  3rd Qu.:111.00  
.  Max.   :119.97&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we simulate with &lt;code&gt;FLAG=1&lt;/code&gt;, the &lt;code&gt;simeta&lt;/code&gt; code &lt;strong&gt;is&lt;/strong&gt; called and we &lt;code&gt;BASE&lt;/code&gt; values within the specified bounds.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;simeps-example&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;code&gt;simeps&lt;/code&gt; example&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;In this example, we want to re-simulate the residual error variate to make sure we have a concentration that is positive.&lt;/li&gt;
&lt;li&gt;We set up a loop that looks like the &lt;code&gt;simeta&lt;/code&gt; example, but we work in &lt;code&gt;$TABLE&lt;/code&gt; this time because we are calculating &lt;code&gt;CP&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;code &amp;lt;- &amp;#39;
$PARAM CL = 1, V = 20, FLAG=0

$SIGMA 50

$PKMODEL cmt=&amp;quot;CENT&amp;quot;

$TABLE
capture CP = CENT/V + EPS(1);

int i = 0;
while(CP &amp;lt; 0 &amp;amp;&amp;amp; FLAG &amp;gt; 0) {
  if(++i &amp;gt; 100) {
    report(&amp;quot;Problem simulating positive CP&amp;quot;);
  }
  simeps();
  CP = CENT/V + EPS(1);
}

&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod &amp;lt;- mcode(&amp;quot;simeps&amp;quot;, code)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Compiling simeps ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. done.&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;simulate-without-simeps&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulate without &lt;code&gt;simeps&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time({
  out &amp;lt;- mod %&amp;gt;% ev(amt=100) %&amp;gt;% mrgsim(end=48)
  sum &amp;lt;- summary(out)
})&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.    user  system elapsed 
.    0.01    0.00    0.01&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.        ID         time            CENT              CP           
.  Min.   :1   Min.   : 0.00   Min.   :  0.00   Min.   :-20.18905  
.  1st Qu.:1   1st Qu.:11.25   1st Qu.: 15.93   1st Qu.: -3.46786  
.  Median :1   Median :23.50   Median : 29.38   Median : -0.03189  
.  Mean   :1   Mean   :23.52   Mean   : 37.47   Mean   : -0.21637  
.  3rd Qu.:1   3rd Qu.:35.75   3rd Qu.: 54.21   3rd Qu.:  4.33185  
.  Max.   :1   Max.   :48.00   Max.   :100.00   Max.   : 14.10283&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Negative&lt;/strong&gt; concentrations are simulated when we &lt;strong&gt;don’t&lt;/strong&gt; call the &lt;code&gt;simeps&lt;/code&gt; loop.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;simulate-with-simeps&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Simulate with &lt;code&gt;simeps&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;system.time({
  out &amp;lt;- mod %&amp;gt;% ev(amt=100) %&amp;gt;% mrgsim(end=48, param=list(FLAG=1))
  sum &amp;lt;- summary(out)
})&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.    user  system elapsed 
.    0.01    0.00    0.01&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;print(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.        ID         time            CENT              CP          
.  Min.   :1   Min.   : 0.00   Min.   :  0.00   Min.   : 0.01688  
.  1st Qu.:1   1st Qu.:11.25   1st Qu.: 15.93   1st Qu.: 2.44887  
.  Median :1   Median :23.50   Median : 29.38   Median : 6.05270  
.  Mean   :1   Mean   :23.52   Mean   : 37.47   Mean   : 6.16352  
.  3rd Qu.:1   3rd Qu.:35.75   3rd Qu.: 54.21   3rd Qu.: 9.21095  
.  Max.   :1   Max.   :48.00   Max.   :100.00   Max.   :14.05398&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Better … all concentrations are positive.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
