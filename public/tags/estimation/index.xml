<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Estimation on mrgsolve</title>
    <link>/tags/estimation/index.xml</link>
    <description>Recent content in Estimation on mrgsolve</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/estimation/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Generate MAP Bayes Parameter Estimates</title>
      <link>/2017/02/23/generate-map-bayes-parameter-estimates/</link>
      <pubDate>Thu, 23 Feb 2017 13:30:33 +0000</pubDate>
      
      <guid>/2017/02/23/generate-map-bayes-parameter-estimates/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;



&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;

&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(mrgsolve)
library(minqa)
library(dplyr)
library(magrittr)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;about&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;About&lt;/h1&gt;
&lt;p&gt;This tutorial illustrates how to do MAP Bayes estimation with &lt;code&gt;mrgsolve&lt;/code&gt;.&lt;br /&gt;
The setup was adapted from an existing project, where only a single individual was considered. With some additional &lt;code&gt;R&lt;/code&gt; coding, it could be expanded to consider multiple individuals in a single run.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;one-compartment-model-keep-it-simple-for-now&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;One compartment model, keep it simple for now&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The model specification code below is for a one-compartment model, where &lt;code&gt;mrgsolve&lt;/code&gt; will calculate the amount in &lt;code&gt;CENT&lt;/code&gt; from closed-form equations&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For now, &lt;code&gt;$OMEGA&lt;/code&gt; and &lt;code&gt;$SIGMA&lt;/code&gt; are filled with zeros; we’ll update it later&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The control stream is set up so that we can either simulate the etas or pass them in. &lt;code&gt;ETA(1)&lt;/code&gt; and &lt;code&gt;ETA(2)&lt;/code&gt; are the etas that &lt;code&gt;mrgsolve&lt;/code&gt; will draw from &lt;code&gt;$OMEGA&lt;/code&gt;. &lt;code&gt;ETA1&lt;/code&gt; and &lt;code&gt;ETA2&lt;/code&gt; are fixed and known at the time of time of the simulation. The optimizer will search for values of &lt;code&gt;ETA1&lt;/code&gt; and &lt;code&gt;ETA2&lt;/code&gt; that optimize the objective function. Note that &lt;code&gt;ETA1&lt;/code&gt; and &lt;code&gt;ETA2&lt;/code&gt; must be in the parameter list for this to work&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We do a trick where &lt;code&gt;CL=TVCL*exp(ETA1+ETA(1));&lt;/code&gt; The assumption is that either &lt;code&gt;ETA1&lt;/code&gt; (simulating) is zero or &lt;code&gt;ETA(1)&lt;/code&gt; is zero (estimating)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;We table out &lt;code&gt;ETA(1)&lt;/code&gt; and &lt;code&gt;ETA(2)&lt;/code&gt; so we can know the true (simulated) values (but not both zero and not both non-zero)&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;DV&lt;/code&gt; is output as a function of &lt;code&gt;EPS(1)&lt;/code&gt;; this will be zero until we add in values for &lt;code&gt;$SIGMA&lt;/code&gt;. But when we’re estimating, we need to make sure that &lt;code&gt;EPS(1)&lt;/code&gt; is zero; the prediction shouldn’t have any randomness in it (just the individual prediction based on known etas)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;code &amp;lt;- &amp;#39;
$SET request=&amp;quot;&amp;quot;

$PARAM TVCL=1.5, TVVC=23.4, ETA1=0, ETA2=0

$CMT CENT

$PKMODEL ncmt=1

$OMEGA 0 0
$SIGMA 0

$MAIN
double CL = TVCL*exp(ETA1 + ETA(1));
double V =  TVVC*exp(ETA2 + ETA(2));

$TABLE 
double DV = (CENT/V)*(1+EPS(1));
double ET1 = ETA(1);
double ET2 = ETA(2);

$CAPTURE DV ET1 ET2
&amp;#39;

mod &amp;lt;- mcode(&amp;quot;map&amp;quot;, code)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;first-simulate-some-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;First, simulate some data&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;$OMEGA&lt;/code&gt; and &lt;code&gt;$SIGMA&lt;/code&gt;;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The result may look better or worse depending on what we choose here&lt;/li&gt;
&lt;li&gt;These will be used to both simulate and fit the data&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;cmat&lt;/code&gt; call makes a &lt;code&gt;2x2&lt;/code&gt; matrix where the off-diagonal is a correlation (&lt;code&gt;?cmat&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;omega &amp;lt;- cmat(0.23,-0.78, 0.62)
omega.inv &amp;lt;- solve(omega)
sigma &amp;lt;- matrix(0.0032)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just a single dose to &lt;code&gt;CENT&lt;/code&gt; with an events object&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dose &amp;lt;- ev(amt=750,cmt=1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Take these times for concentration observations&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sampl &amp;lt;- c(0.5,12,24)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Simulate&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Here, we’re populating &lt;code&gt;$OMEGA&lt;/code&gt; and &lt;code&gt;$SIGMA&lt;/code&gt; so that the simulated data will be random&lt;/li&gt;
&lt;li&gt;It is important to &lt;code&gt;carry.out&lt;/code&gt; all of the items that we will need in the estimation data set (doses, evid, etc)&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;end=-1&lt;/code&gt; with &lt;code&gt;add=sampl&lt;/code&gt; makes sure that we only get observation records at the times listed in &lt;code&gt;sampl&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1012) 
sim &amp;lt;- 
  mod %&amp;gt;%
  ev(dose) %&amp;gt;%
  omat(omega) %&amp;gt;%
  smat(sigma) %&amp;gt;%
  carry.out(amt,evid,cmt) %&amp;gt;%
  mrgsim(end=-1, add=sampl)

sim&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Model:  map.cpp 
. Dim:    4 x 8 
. Time:   0 to 24 
. ID:     1 
.      ID time evid amt cmt     DV    ET1     ET2
. [1,]  1  0.0    1 750   1 41.067 0.5196 -0.2728
. [2,]  1  0.5    0   0   0 42.749 0.5196 -0.2728
. [3,]  1 12.0    0   0   0  6.932 0.5196 -0.2728
. [4,]  1 24.0    0   0   0  1.375 0.5196 -0.2728&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;create-input-for-optimization&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Create input for optimization&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Using the simulated data as the starting point here&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim %&amp;lt;&amp;gt;% as.data.frame&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observed data (&lt;code&gt;y&lt;/code&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Just select &lt;code&gt;DV&lt;/code&gt; from observation records&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;y &amp;lt;- sim %&amp;gt;% filter(evid==0) %&amp;gt;% select(DV) %&amp;gt;% unlist %&amp;gt;% unname

y&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. [1] 42.749445  6.932391  1.374557&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a data set to use in the optimization&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We need to drop &lt;code&gt;ET1&lt;/code&gt; and &lt;code&gt;ET2&lt;/code&gt; since they are in the parameter list&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- sim %&amp;gt;% select(-ET1, -ET2)
data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID time evid amt cmt        DV
. 1  1  0.0    1 750   1 41.067037
. 2  1  0.5    0   0   0 42.749445
. 3  1 12.0    0   0   0  6.932391
. 4  1 24.0    0   0   0  1.374557&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;optimize&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Optimize&lt;/h1&gt;
&lt;p&gt;This function takes in a set of proposed &lt;span class=&#34;math inline&#34;&gt;\(\eta\)&lt;/span&gt;s along with the observed data vector, the data set and a model object and returns the value of the EBE objective function&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;When we do the estimation, the fixed effects and random effect variances are fixed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The estimates are the &lt;span class=&#34;math inline&#34;&gt;\(\eta\)&lt;/span&gt; for clearance and volume&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;eta&lt;/code&gt; the current values from the optimizer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; the observed data&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; the data set that generated &lt;code&gt;y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; the model object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pred&lt;/code&gt; if &lt;code&gt;TRUE&lt;/code&gt;, just return predicted values&lt;/li&gt;
&lt;/ul&gt;
&lt;div id=&#34;what-is-this-function-doing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;What is this function doing?&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;get the matrix for residual error&lt;/li&gt;
&lt;li&gt;Make sure &lt;code&gt;eta&lt;/code&gt; is a list&lt;/li&gt;
&lt;li&gt;Make sure &lt;code&gt;eta&lt;/code&gt; is properly named (i.e. &lt;code&gt;ETA1&lt;/code&gt; and &lt;code&gt;ETA2&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Copy &lt;code&gt;eta&lt;/code&gt; into a matrix that is one row&lt;/li&gt;
&lt;li&gt;Update the model object (&lt;code&gt;m&lt;/code&gt;) with the current values of &lt;code&gt;ETA1&lt;/code&gt; and &lt;code&gt;ETA2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;If we are estimating (&lt;code&gt;!pred&lt;/code&gt;), request only observations in the output (&lt;code&gt;obsonly&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Simulate from data set &lt;code&gt;d&lt;/code&gt; and save output to &lt;code&gt;out&lt;/code&gt; object&lt;/li&gt;
&lt;li&gt;If we are just requesting predictions (&lt;code&gt;if(pred)&lt;/code&gt;) return the simulated data&lt;/li&gt;
&lt;li&gt;The final lines calculate the EBE objective function; see &lt;a href=&#34;http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3339294/&#34;&gt;this paper&lt;/a&gt; for reference&lt;/li&gt;
&lt;li&gt;Notice that the function returns a single value (a number); the optimizer will minimize this value&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mapbayes &amp;lt;- function(eta,y,d,m,pred=FALSE) {
    
  sig2 &amp;lt;- as.numeric(sigma)
  eta %&amp;lt;&amp;gt;% as.list
  names(eta) &amp;lt;- names(init)
  eta_m &amp;lt;- eta %&amp;gt;% unlist %&amp;gt;% matrix(nrow=1)
  m %&amp;lt;&amp;gt;% param(eta)
  if(!pred) m %&amp;lt;&amp;gt;% obsonly
  out &amp;lt;- m %&amp;gt;% drop.re() %&amp;gt;% data_set(d) %&amp;gt;% mrgsim
  if(pred) return(out %&amp;gt;% as.tbl)
  # http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3339294/
  sig2j &amp;lt;- out$DV^2*sig2
  sqwres &amp;lt;- log(sig2j) + (1/sig2j)*(y-out$DV)^2
  nOn &amp;lt;- diag(eta_m %*% omega.inv %*% t(eta_m))
  return(sum(sqwres) + nOn)

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;initial-estimate&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Initial estimate&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Note again that we are optimizing the etas here&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;init &amp;lt;- c(ETA1=-0.3, ETA2=0.2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fit the data&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newuoa&lt;/code&gt; is from the &lt;code&gt;minqa&lt;/code&gt; package&lt;/li&gt;
&lt;li&gt;Other optimizers (via &lt;code&gt;optim&lt;/code&gt;) could probably also be used&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Arguments to &lt;code&gt;newuoa&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First: the initial estimates&lt;/li&gt;
&lt;li&gt;Second: the function to optimize&lt;/li&gt;
&lt;li&gt;The other argument are passed to &lt;code&gt;mapbayes&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit &amp;lt;- newuoa(init,mapbayes,y=y,m=mod,d=data)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are the final estimates&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit$par&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. [1]  0.4995400 -0.3274858&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here are the simulated values&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;slice(sim,1) %&amp;gt;% select(ET1, ET2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.        ET1        ET2
. 1 0.519569 -0.2727675&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;look-at-the-result&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Look at the result&lt;/h1&gt;
&lt;p&gt;A data set and model to get predictions; this will give us a smooth prediction line&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pdata &amp;lt;- data %&amp;gt;% filter(evid==1)
pmod &amp;lt;- mod %&amp;gt;% update(end=24, delta=0.1) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Predicted line based on final estimates&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred &amp;lt;- mapbayes(fit$par,y,pdata,pmod,pred=TRUE) %&amp;gt;% filter(time &amp;gt; 0)
head(pred)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. # A tibble: 6 × 5
.      ID  time       DV   ET1   ET2
.   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
. 1     1   0.1 43.82331     0     0
. 2     1   0.2 43.18567     0     0
. 3     1   0.3 42.55731     0     0
. 4     1   0.4 41.93809     0     0
. 5     1   0.5 41.32789     0     0
. 6     1   0.6 40.72656     0     0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Predicted line based on initial estimates&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;initial &amp;lt;- mapbayes(init,y,pdata,pmod,pred=TRUE) %&amp;gt;% filter(time &amp;gt; 0)
head(initial)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. # A tibble: 6 × 5
.      ID  time       DV   ET1   ET2
.   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
. 1     1   0.1 26.13954     0     0
. 2     1   0.2 26.03811     0     0
. 3     1   0.3 25.93707     0     0
. 4     1   0.4 25.83642     0     0
. 5     1   0.5 25.73616     0     0
. 6     1   0.6 25.63629     0     0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plot&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() + 
  geom_line(data=pred, aes(time,DV),col=&amp;quot;firebrick&amp;quot;, lwd=1) + 
  geom_line(data=initial,aes(time,DV), lty=2, col=&amp;quot;darkgreen&amp;quot;, lwd=1) + 
  geom_point(data=data %&amp;gt;% filter(evid==0), aes(time,DV), col=&amp;quot;darkslateblue&amp;quot;,size=3)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;#####content/post/map_bayes_files/figure-html/unnamed-chunk-19-1.png&#34; width=&#34;672&#34; style=&#34;display: block; margin: auto;&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>