<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Plugin on mrgsolve</title>
    <link>/tags/plugin/index.xml</link>
    <description>Recent content in Plugin on mrgsolve</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/tags/plugin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Work with R objects in your model</title>
      <link>/2017/01/01/work-with-r-objects-in-your-model/</link>
      <pubDate>Sun, 01 Jan 2017 13:09:13 -0600</pubDate>
      
      <guid>/2017/01/01/work-with-r-objects-in-your-model/</guid>
      <description>&lt;!-- BLOGDOWN-HEAD --&gt;



&lt;!-- /BLOGDOWN-HEAD --&gt;

&lt;!-- BLOGDOWN-BODY-BEFORE --&gt;

&lt;!-- /BLOGDOWN-BODY-BEFORE --&gt;

&lt;div id=&#34;about&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;About&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;This model doesn’t really accomplish anything useful. I coded this up to show how we can get &lt;code&gt;vector&lt;/code&gt;, &lt;code&gt;matrix&lt;/code&gt; data as well as &lt;code&gt;R&lt;/code&gt; functions into your simulation.&lt;/li&gt;
&lt;li&gt;After we show the model code, we walk through the key lines of code and explain why / where this type of extension could be useful.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;documentation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Documentation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;You can find documentation for functions in &lt;code&gt;mrgx&lt;/code&gt; plugin here: &lt;a href=&#34;http://mrgsolve.github.io/doxygen/&#34; class=&#34;uri&#34;&gt;http://mrgsolve.github.io/doxygen/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Follow the &lt;code&gt;mrgx&lt;/code&gt; “module”&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;example&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Example&lt;/h1&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(dplyr)
library(mrgsolve)
library(magrittr)
library(ggplot2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;code &amp;lt;- &amp;#39;
$PARAM xout = 13

$PLUGIN Rcpp mrgx

$GLOBAL 
Rcpp::Function appx(&amp;quot;approx&amp;quot;); 
Rcpp::NumericVector x;
Rcpp::NumericVector y;

$PREAMBLE
x = mrgx::get&amp;lt;Rcpp::NumericVector&amp;gt;(&amp;quot;x&amp;quot;, self);
y = mrgx::get&amp;lt;Rcpp::NumericVector&amp;gt;(&amp;quot;y&amp;quot;, self);

$MAIN
Rcpp::List out = appx(x,y,xout);
double yout = Rcpp::as&amp;lt;double&amp;gt;(out[&amp;quot;y&amp;quot;]);

$ENV
set.seed(11122)
n &amp;lt;- 10
x &amp;lt;- sort(runif(n,10,20))
y &amp;lt;- sort(rnorm(n))

$CAPTURE xout yout
&amp;#39;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;not-sure-whats-going-on&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Not sure what’s going on?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Scroll down to the bottom for some context and discussion.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;about-the-code&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;About the code&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Use &lt;code&gt;$PLUGIN&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Rcpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mrgx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;We declare some variables in &lt;code&gt;$GLOBAL&lt;/code&gt; so we can use them in any part of the model
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;appx&lt;/code&gt; is the &lt;code&gt;R&lt;/code&gt; function &lt;code&gt;approx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; will be the &lt;code&gt;x&lt;/code&gt; argument to &lt;code&gt;stats::approx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; will be the &lt;code&gt;y&lt;/code&gt; argument to &lt;code&gt;stats::approx&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xout&lt;/code&gt; enters as a parameter (we can change it); that also gets passed to &lt;code&gt;stats::approx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$PREAMBLE&lt;/code&gt; gets called &lt;strong&gt;ONCE&lt;/strong&gt; we set thing up there
&lt;ul&gt;
&lt;li&gt;We &lt;code&gt;mrgx::get&lt;/code&gt; some &lt;code&gt;Rcpp::NumericVector&lt;/code&gt;s (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;) from the model &lt;code&gt;$ENV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Note that the call is &lt;code&gt;mrgx::get&amp;lt;Rcpp::NumericVector&amp;gt;&lt;/code&gt;; &lt;code&gt;mrgx::get&lt;/code&gt; is a templated function, so we need to say what type we are working with.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Now, in &lt;code&gt;$MAIN&lt;/code&gt; we can call the &lt;code&gt;appx&lt;/code&gt; function and pass in &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;xout&lt;/code&gt;.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;appx&lt;/code&gt; returns the result as a &lt;code&gt;Rcpp::List&lt;/code&gt;. We’re interested in the &lt;code&gt;y&lt;/code&gt; element in that list, so we need to get specific about what type (&lt;code&gt;double&lt;/code&gt;) that needs to be.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;more-info&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;More info&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mrgsolve.github.io/user_guide/model-specification.html#block-plugin&#34; class=&#34;uri&#34;&gt;http://mrgsolve.github.io/user_guide/model-specification.html#block-plugin&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mod &amp;lt;- mcode(&amp;quot;approx&amp;quot;, code)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. Compiling approx ...&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. done.&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;e &amp;lt;- env_get(mod)

approx(e$x,e$y, xout=13)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;. $x
. [1] 13
. 
. $y
. [1] 0.2543653&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mrgsim(mod, end=-1) %&amp;gt;% as.data.frame&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;.   ID time xout      yout
. 1  1    0   13 0.2543653&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;what-problem-does-this-solve&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;What problem does this solve?&lt;/h1&gt;
&lt;p&gt;So you might be asking, why do you need to do all of this? The general goal is to allow you to get a variety of data structures into your model code.&lt;/p&gt;
&lt;p&gt;So far, you’ve been able to get scalar values via the &lt;code&gt;$PARAM&lt;/code&gt; list. This allows you to say what the &lt;code&gt;TVCL&lt;/code&gt; is or the &lt;code&gt;KA&lt;/code&gt; or the patient &lt;code&gt;WT&lt;/code&gt; etc. When you specify parameters with those names, those symbols take (scalar) values and we can use them in the code and we can update those values in a couple of different ways. Note that you also can input matrices in &lt;code&gt;$OMEGA&lt;/code&gt; and &lt;code&gt;$SIGMA&lt;/code&gt;, but you don’t get direct access to those matrices … only the variates that were drawn using those matrices.&lt;/p&gt;
&lt;p&gt;We’ve hit the point where getting scalar data into the problem isn’t enough. Now, we are working on models that require &lt;code&gt;vector&lt;/code&gt; data or specification of &lt;code&gt;matrix&lt;/code&gt; data. Usually we are requiring those data structures in &lt;code&gt;numeric&lt;/code&gt; format. We would also like to call &lt;code&gt;R&lt;/code&gt; functions using that data to do calculations necessary for the model simulation to proceed.&lt;/p&gt;
&lt;p&gt;The models we are talking about are complex and still fairly unusual. I expect 95% of users to never need stuff like this. But I think it’s important for those who do need this extra functionality to be able to access it. Otherwise, the modeling hits a roadblock.&lt;/p&gt;
&lt;p&gt;The general mechanism for specifying non-scalar data to get into the problem is through &lt;code&gt;$ENV&lt;/code&gt;. This block is just regular old &lt;code&gt;R&lt;/code&gt; code that gets parsed and evaluated into a new &lt;code&gt;environment&lt;/code&gt;. That environment stays with the model object and we access the objects in that environment or modify them (similar to the way we work with a &lt;code&gt;$PARAM&lt;/code&gt; list).&lt;/p&gt;
&lt;p&gt;Because many different data types could possibly be in the mix now, we need to take an extra step or two to access those objects. This means an extra step to go into the &lt;code&gt;$ENV&lt;/code&gt; environment, and &lt;code&gt;get&lt;/code&gt; an object. This usually only needs to be done &lt;strong&gt;ONCE&lt;/strong&gt; … at the start of the problem. We go get the required objects and have them ready to use as the simulation proceeds. This is essentially what the &lt;code&gt;$PREAMBLE&lt;/code&gt; block is for: it is a C++ function (like &lt;code&gt;$MAIN&lt;/code&gt;) that gets called once and lets you set up the C++ environment as you please … including extracting objects from your &lt;code&gt;$ENV&lt;/code&gt; (or potentially from &lt;code&gt;.GlobalEnv&lt;/code&gt;) or from other &lt;code&gt;R&lt;/code&gt; packages.&lt;/p&gt;
&lt;p&gt;You will see illustrated below several functions in the &lt;code&gt;mrgx&lt;/code&gt; plugin that help you do this. Remember also that since we are importing &lt;code&gt;R&lt;/code&gt; objects that are &lt;code&gt;vectors&lt;/code&gt;, &lt;code&gt;matrices&lt;/code&gt;, and &lt;code&gt;functions&lt;/code&gt;, we also need to invoke the &lt;code&gt;Rcpp&lt;/code&gt; plugin.&lt;/p&gt;
&lt;p&gt;Note that we are getting and calling an &lt;code&gt;R&lt;/code&gt; function in this problem. This is fine if no other alternative is available / possible. But be aware that there will be &lt;strong&gt;some&lt;/strong&gt; performance ding for this. It would be much more efficient to code an &lt;code&gt;Rcpp&lt;/code&gt; version of &lt;code&gt;approx&lt;/code&gt;. We have that function and it does speed things up. Hopefully another vignette coming that illustrates how to set up that function.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
